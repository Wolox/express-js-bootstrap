<% if(orm.sequelize) {%>const { factory } = require('factory-girl');
const Chance = require('chance');
const db = require('../../app/models');

const INTEGER = 'INTEGER';
const STRING = 'STRING';
const BOOLEAN = 'BOOLEAN';
const TEXT = 'TEXT';
const DATE = 'DATE';
const DATEONLY = 'DATEONLY';
const JSONTYPE = 'JSON';
const FLOAT = 'FLOAT';

const IS_NUMERIC = 'isNumeric';
const IS_ALPHANUMERIC = 'isAlphanumeric';
const IS_LOWERCASE = 'isLowercase';
const IS_UPPERCASE = 'isUppercase';
const IS_IP = 'isIP';
const MAX = 'max';
const MIN = 'min';
const LEN = 'len';

const modelsByName = Object.keys(db)
  .filter(modelName => modelName !== 'sequelize' && modelName !== 'Sequelize')
  .reduce((models, modelName) => {
    models[modelName] = db[modelName];
    return models;
  }, {});

const generatorIntByValidations = (key, validate) => {
  if (key === LEN) {
    return factory.chance('integer', { min: validate.len[0], max: validate.len[1] });
  }
  return {
    [MAX]: factory.chance('integer', { max: validate.max }),
    [MIN]: factory.chance('integer', { min: validate.min })
  }[key];
};

const generatorStringByValidations = key =>
  ({
    [IS_ALPHANUMERIC]: factory.chance('string', { pool: 'abcde6546' }),
    [IS_NUMERIC]: factory.chance('string', { pool: '123456789' }),
    [IS_LOWERCASE]: factory.chance('string', { pool: 'abcdefghijklmnopqrstuvwxyz' }),
    [IS_UPPERCASE]: factory.chance('string', { pool: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' }),
    [IS_IP]: factory.chance('ip')
  }[key]);

const generateStringByValidations = validate =>
  Object.keys(validate).map(key => generatorStringByValidations(key))[0];

const generateIntByValidations = validate =>
  Object.keys(validate).map(key => generatorIntByValidations(key, validate))[0];

const intValidation = (model, key) => {
  if (model.rawAttributes[key].unique) {
    return factory.sequence(`${model.name}.${key}`, n => n);
  }
  if (model.rawAttributes[key].validate) {
    const { validate } = model.rawAttributes[key];
    return generateIntByValidations(validate) || factory.chance('integer');
  }
  return factory.chance('integer');
};

const emailFactory = (model, key) => {
  if (model.rawAttributes[key].validate.isEmail) {
    if (model.rawAttributes[key].unique) {
      return factory.sequence(`${model.name}.email`, n => `dummy-user-${n}@wolox.com.ar`);
    }
    return factory.chance('email', { domain: 'wolox.com.ar' });
  }
  return false;
};

const stringValidation = (model, key) => {
  const chance = new Chance();
  if (model.rawAttributes[key].validate) {
    const { validate } = model.rawAttributes[key];
    if (emailFactory(model, key)) {
      return emailFactory(model, key);
    }
    if (validate.contains) {
      const word = chance.string({ pool: 'abcdefghi' });
      return factory.sequence(`${model.name}`, n => `${validate.contains}${word}${n}`);
    }
    return generateStringByValidations(validate);
  }
  return factory.chance('word');
};

const randomJsonCreate = () => {
  const chance = new Chance();
  const attributeName = chance.string({ pool: 'abcdefghi' });
  const value = factory.chance('string', { pool: 'abcdefghi' });
  return {
    [attributeName]: value
  };
};

const generatorByDatatype = (type, model, key) => {
  const chance = new Chance();
  return {
    [INTEGER]: intValidation(model, key),
    [STRING]: stringValidation(model, key),
    [BOOLEAN]: factory.chance('bool'),
    [TEXT]: factory.chance('paragraph'),
    [DATE]: factory.chance('date', { string: true }),
    [DATEONLY]: new Date(chance.date({ string: true })),
    [JSONTYPE]: randomJsonCreate(),
    [FLOAT]: factory.chance('floating')
  }[type];
};

const generateByDatatypes = (model, key, attribute, predeterminatedValue = false) => {
  if (predeterminatedValue && key === predeterminatedValue.attribute) {
    return predeterminatedValue.value;
  }
  if (model.rawAttributes[key].defaultValue !== undefined) {
    return model.rawAttributes[key].defaultValue;
  }
  return generatorByDatatype(attribute[key], model, key) || factory.chance('word');
};

const buildByModel = (model, predeterminatedValue = false) => {
  const attributeType = {};
  const factorCreated = {};
  for (const key in model.rawAttributes) {
    if (key) {
      attributeType[key] = model.rawAttributes[key].type.key;
      if (!model.rawAttributes[key].primaryKey) {
        factorCreated[key] = generateByDatatypes(model, key, attributeType, predeterminatedValue);
      }
    }
  }
  return factorCreated;
};

exports.factoryByModel = (modelRequired, predeterminatedValue = false) => {
  const modelRequested = modelsByName[modelRequired];
  const factorCreated = buildByModel(modelRequested, predeterminatedValue);
  return factory.define(modelRequested.name, db[modelRequested.name], factorCreated);
};

exports.factoryAllModels = () => {
  const models = modelsByName;
  return Object.keys(models).forEach(model => this.factoryByModel(model));
};

exports.factoryWithCustomizedValue = (modelRequired, attribute, value) => {
  const predeterminatedValue = {
    attribute,
    value
  };
  return this.factoryByModel(modelRequired, predeterminatedValue);
};<%}%>
<% if(orm.mongoose && mongooseDialect === 'mongoDB') {%>const { factory } = require('factory-girl');
const mongoose = require('mongoose');
const Chance = require('chance');
const { Schema } = mongoose;

const NUMBER = 'number';
const STRING = 'string';
const BOOLEAN = 'boolean';
const ARRAY = 'array';
const DATE = 'date';
const OBJECT = 'object';

const getArrayOfModels = modelConfig => Object.keys(modelConfig).filter(model => !model.includes('_'));

const randomJsonCreate = () => {
  const chance = new Chance();
  const attributeName = chance.string({ pool: 'abcdefghi' });
  const value = factory.chance('string', { pool: 'abcdefghi' });
  return {
    [attributeName]: value
  };
};

const randomArrayCreate = (length = false) => {
  const chance = new Chance();
  const arrayLength = length ? length : chance.integer({ min: 1, max: 10 });
  const array = [];
  for (let i = 0; i < arrayLength; i++) {
    const value = chance.string();
    array.push(value);
  }
  return array;
};

const generatorByDatatype = type =>
  ({
    [NUMBER]: factory.chance('integer'),
    [STRING]: factory.chance('word'),
    [BOOLEAN]: factory.chance('bool'),
    [ARRAY]: randomArrayCreate(),
    [DATE]: factory.chance('date', { string: true }),
    [OBJECT]: randomJsonCreate()
  }[type]);

const generateFactorByModel = property => {
  if (property.type === ['object']) {
    return [{}];
  }
  return generatorByDatatype(property.type);
};

const replaceValuesByCustomized = (custom, factorCreated) => {
  Object.keys(custom).forEach(attrib => {
    factorCreated[attrib] = custom[attrib];
  });
  return factorCreated;
};

const generatorOfFactoriesByKey = properties =>
  Object.keys(properties).reduce((previous, current) => {
    previous[current] = generateFactorByModel(properties[current]);
  }, {});

exports.factoryByModel = (model, modelsRoute, custom = false) => {
  /* eslint-disable global-require */
  const modelToFactor = require(`${modelsRoute}/${model}.json`);
  /* eslint-enable global-require */
  const factorCreated = generatorOfFactoriesByKey(modelToFactor.properties);
  const modelSchema = new Schema(modelToFactor.properties);
  const modelMongoose = mongoose.model(`${model}`, modelSchema);
  if (custom) {
    const newFactor = replaceValuesByCustomized(custom, factorCreated);
    return factory.define(model, modelMongoose, newFactor);
  }
  return factory.define(model, modelMongoose, factorCreated);
};

exports.factoryAllModels = (modelConfigRoute, modelsRoute, customByModel = false) => {
  /* eslint-disable global-require */
  const modelConfig = require(modelConfigRoute);
  /* eslint-enable global-require */
  const models = getArrayOfModels(modelConfig);
  return models.forEach(model =>
    customByModel && customByModel[model]
      ? exports.factoryByModel(model, modelsRoute, customByModel[model])
      : exports.factoryByModel(model, modelsRoute)
};

<%}%>
